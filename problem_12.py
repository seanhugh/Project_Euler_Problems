#!/usr/bin/env python
'''
projectEuler.com   problem 12

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

Coded by: Sean Hughes 1/28/15
'''
re_run = 'true'
numbruh = 0
factors = []
def triangle_num(x):
    num = ((x+1)/2)*x
    return num
def check_prime(num):
    if num ==1: return 'false'
    if num ==2: return 'true'
    if num % 2 == 0: return 'false'
    for j in range(3, int((num+1)**.5)+1, 2):
        if  (num % j == 0) and (num != j):
            return 'false'
    return 'true'
def factor(x):
    for i in range(2, int(x**.5)+1):
        if x % i == 0:
            factors.append(i)
            if check_prime(x/i)=='true':
                factors.append(x/i)
                return factors
            else:
                factor(x/i)
                return factors
def exponents(list):
    #this has to be done
    exponents = []
    used = []
    for i in list:
        if i not in used:
            exponents.append(list.count(i))
            used.append(i)
    factors[:]=[]
    return exponents
def calculate_roots(exponent_nums):
    roots = 1
    for i in exponent_nums:
        roots = (i+1)*roots
    return roots

def trianglenum2roots(num):
    return calculate_roots(exponents(factor(triangle_num(num))))
    
#exponents and factor have to be paired!! (Or else you have to delete factor[])
runs = 10
current_roots = 0
while current_roots <=500:
    current_roots = trianglenum2roots(runs)
    print runs, triangle_num(runs), current_roots
    runs +=1
print triangle_num(runs), runs, current_roots




#this works but is not efficient enough (below)
'''def divisors(x):
    factors = []
    for i in range(1, x+1):
        if x % i == 0 and i <= x/i:
            factors.append([i, x/i])
        if i> x/i:
            return factors
    return factors
print divisors(500)'''
'''while re_run == 'true':
    if num_divisors(triangle_num(numbruh)) > 250:
        re_run = 'false'
    else:
        print triangle_num(numbruh), num_divisors(triangle_num(numbruh))
        numbruh +=1'''
