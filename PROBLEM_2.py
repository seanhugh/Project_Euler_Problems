#!/usr/bin/env python
'''
CODED by Sean Hughes 2/18/15

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
Goal is to find the sum of all even fibonacci numbers from 1 - 4,000,000

The code below shows the four steps in my optimization of this problem. Numbers 1 and 2 below were done by myself with no outside resources.
For number 3 I used an outside math theorem and for number 4 i converted from C code. The following is my source for numbers 3 and 4:
http://www.mathblog.dk/project-euler-problem-2/
'''
import timeit
start = timeit.default_timer()

#-----------------------------------------------------------------------------------------------------------------
'''
first go: 1.92745075363 ms
basically I just have 3 variables (fib1, fib2, fib3) and I go through the fibonacci sequence with them
I used three because the sequence goes even odd odd even odd odd..... and so on. So, one of the variables
(fib2) will always be even. I can then calculate the total by adding fib2 to a variable, total, every go around
'''
fib1 = 1
fib2 = 2
fib3 = 0
final = 2
target = 4000000
while (fib1 <= target) and (fib2 <= target) and (fib3 <= target):
    fib3 = fib1 + fib2
    fib1 = fib2 + fib3
    fib2 = fib3 + fib1
    if fib2<4000000:
        final += fib2
print final
#-----------------------------------------------------------------------------------------------------------------
'''
Second Go: 0.0246954627809 ms
basically the same thing just did a little organization and messing with the print function so that it is faster.
This eliminates an if statemetn and speeds up the algorithm
'''
num1 = 1
num2 = 1
num3 = 0
final = 0
while num1<4000000 and num2<4000000 and num3 < 4000000:
    final += num3
    num1 = num2 + num3
    num2 = num3 + num1
    num3 = num1 + num2
print final
#-----------------------------------------------------------------------------------------------------------------
'''
Third Go: (Used online resources to really optomize code) 0.0234908060599 ms
This uses the mathmetical derivation of Fn for the sequence. So Fn = Fn-1 + Fn-2.. You can derive this to use only even
terms by then bringing it to terms of Fn-3 and Fn-6... This ends up being Fn = 4*Fn-3 + Fn-6.... So, it is essentially
only counting up by even numbers which makes it slightly more efficient
'''
fib3 = 2
fib6 = 0
result = 2
final = 0

while (result < 4000000):
    final += result
    result = 4*fib3 + fib6
    fib6 = fib3
    fib3 = result
print final
#-----------------------------------------------------------------------------------------------------------------
'''
fourth go: http://www.mathblog.dk/project-euler-problem-2/ 0.0421629852357 ms
took this code from this site which I've been using to help optomize after I finish the code (It is in C but i converted it)
basically the only difference between this and the code before is that it uses a list instead of an int,
which basically just cleans it up and makes it more efficient
'''
fib = [2, 0]
i = 0
final = 0
 
while fib[i] < 4000000:
    final += fib[i]
    i = (i + 1) % 2
    #clever piece of code right here ^. The % function divides the left by the right and returns the remainder. So,
    #this adds one to i and then returns the remainder when 2 is divided by it. So, it will return 0 then 1 then 0
    #then 1 and so on.
    fib[i] = 4 * fib[(i + 1) % 2] + fib[i]

#End part of timer code:
stop = timeit.default_timer()
a = stop - start
print final
print "it took", a*1000, "ms"
